/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface AdminCAInterface extends utils.Interface {
  functions: {
    "_maxTxAmount()": FunctionFragment;
    "_maxWalletSize()": FunctionFragment;
    "_rOwned(address)": FunctionFragment;
    "_totalProportion()": FunctionFragment;
    "claimingFees()": FunctionFragment;
    "owner()": FunctionFragment;
    "pair()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "router()": FunctionFragment;
    "swapThreshold()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "whitelistEnabled()": FunctionFragment;
    "whitelistRenounced()": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "decimals()": FunctionFragment;
    "name()": FunctionFragment;
    "changeName(string)": FunctionFragment;
    "changeSymbol(string)": FunctionFragment;
    "symbol()": FunctionFragment;
    "getOwner()": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "allowance(address,address)": FunctionFragment;
    "viewFeesBuy()": FunctionFragment;
    "viewFeesSell()": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "approveMax(address)": FunctionFragment;
    "transfer(address,uint256)": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "tokensToProportion(uint256)": FunctionFragment;
    "tokenFromReflection(uint256)": FunctionFragment;
    "getTotalFeeBuy()": FunctionFragment;
    "getTotalFeeSell()": FunctionFragment;
    "setSwapBackSettings(bool,uint256,uint256,bool)": FunctionFragment;
    "changeFees(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "SetMaxWalletPercent_base1000(uint256)": FunctionFragment;
    "SetMaxTxPercent_base1000(uint256)": FunctionFragment;
    "setIsFeeExempt(address,bool)": FunctionFragment;
    "setIsTxLimitExempt(address,bool)": FunctionFragment;
    "setFeeReceivers(address,address,address)": FunctionFragment;
    "getCirculatingSupply()": FunctionFragment;
    "getLiquidityBacking(uint256)": FunctionFragment;
    "isOverLiquified(uint256,uint256)": FunctionFragment;
    "multiAirdrop(address[],uint256[])": FunctionFragment;
    "manageWhitelist(address[],bool)": FunctionFragment;
    "enableWhitelistMode(bool)": FunctionFragment;
    "renounceWhitelist()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "_maxTxAmount"
      | "_maxWalletSize"
      | "_rOwned"
      | "_totalProportion"
      | "claimingFees"
      | "owner"
      | "pair"
      | "renounceOwnership"
      | "router"
      | "swapThreshold"
      | "transferOwnership"
      | "whitelistEnabled"
      | "whitelistRenounced"
      | "totalSupply"
      | "decimals"
      | "name"
      | "changeName"
      | "changeSymbol"
      | "symbol"
      | "getOwner"
      | "balanceOf"
      | "allowance"
      | "viewFeesBuy"
      | "viewFeesSell"
      | "approve"
      | "approveMax"
      | "transfer"
      | "transferFrom"
      | "tokensToProportion"
      | "tokenFromReflection"
      | "getTotalFeeBuy"
      | "getTotalFeeSell"
      | "setSwapBackSettings"
      | "changeFees"
      | "SetMaxWalletPercent_base1000"
      | "SetMaxTxPercent_base1000"
      | "setIsFeeExempt"
      | "setIsTxLimitExempt"
      | "setFeeReceivers"
      | "getCirculatingSupply"
      | "getLiquidityBacking"
      | "isOverLiquified"
      | "multiAirdrop"
      | "manageWhitelist"
      | "enableWhitelistMode"
      | "renounceWhitelist"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "_maxTxAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_maxWalletSize",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "_rOwned", values: [string]): string;
  encodeFunctionData(
    functionFragment: "_totalProportion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimingFees",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pair", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "router", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "swapThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "whitelistEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "whitelistRenounced",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "changeName", values: [string]): string;
  encodeFunctionData(
    functionFragment: "changeSymbol",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
  encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "viewFeesBuy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "viewFeesSell",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "approveMax", values: [string]): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensToProportion",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenFromReflection",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalFeeBuy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalFeeSell",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setSwapBackSettings",
    values: [boolean, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "changeFees",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "SetMaxWalletPercent_base1000",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "SetMaxTxPercent_base1000",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsFeeExempt",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsTxLimitExempt",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeReceivers",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getCirculatingSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityBacking",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isOverLiquified",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "multiAirdrop",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "manageWhitelist",
    values: [string[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "enableWhitelistMode",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceWhitelist",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "_maxTxAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_maxWalletSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_rOwned", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_totalProportion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimingFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pair", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "router", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "swapThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "whitelistEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "whitelistRenounced",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "changeName", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSymbol",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "viewFeesBuy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewFeesSell",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approveMax", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensToProportion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenFromReflection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalFeeBuy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalFeeSell",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSwapBackSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "changeFees", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "SetMaxWalletPercent_base1000",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "SetMaxTxPercent_base1000",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsFeeExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsTxLimitExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeReceivers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCirculatingSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityBacking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOverLiquified",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multiAirdrop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "manageWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableWhitelistMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceWhitelist",
    data: BytesLike
  ): Result;

  events: {
    "Approval(address,address,uint256)": EventFragment;
    "AutoLiquify(uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Reflect(uint256,uint256)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AutoLiquify"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Reflect"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface AutoLiquifyEventObject {
  amountBNB: BigNumber;
  amountToken: BigNumber;
}
export type AutoLiquifyEvent = TypedEvent<
  [BigNumber, BigNumber],
  AutoLiquifyEventObject
>;

export type AutoLiquifyEventFilter = TypedEventFilter<AutoLiquifyEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ReflectEventObject {
  amountReflected: BigNumber;
  newTotalProportion: BigNumber;
}
export type ReflectEvent = TypedEvent<
  [BigNumber, BigNumber],
  ReflectEventObject
>;

export type ReflectEventFilter = TypedEventFilter<ReflectEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface AdminCA extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: AdminCAInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _maxTxAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    _maxWalletSize(overrides?: CallOverrides): Promise<[BigNumber]>;

    _rOwned(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    _totalProportion(overrides?: CallOverrides): Promise<[BigNumber]>;

    claimingFees(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    pair(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    router(overrides?: CallOverrides): Promise<[string]>;

    swapThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    whitelistEnabled(overrides?: CallOverrides): Promise<[boolean]>;

    whitelistRenounced(overrides?: CallOverrides): Promise<[boolean]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    changeName(
      newName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    changeSymbol(
      newSymbol: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    getOwner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the amount of tokens owned by `account`.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    allowance(
      holder: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    viewFeesBuy(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
    >;

    viewFeesSell(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
    >;

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    approveMax(
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    tokensToProportion(
      tokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokenFromReflection(
      proportion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTotalFeeBuy(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTotalFeeSell(overrides?: CallOverrides): Promise<[BigNumber]>;

    setSwapBackSettings(
      _enabled: boolean,
      _amountS: BigNumberish,
      _amountL: BigNumberish,
      _alternate: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    changeFees(
      _liquidityFeeBuy: BigNumberish,
      _reflectionFeeBuy: BigNumberish,
      _marketingFeeBuy: BigNumberish,
      _buybackFeeBuy: BigNumberish,
      _liquidityFeeSell: BigNumberish,
      _reflectionFeeSell: BigNumberish,
      _marketingFeeSell: BigNumberish,
      _buybackFeeSell: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    SetMaxWalletPercent_base1000(
      maxWallPercent_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    SetMaxTxPercent_base1000(
      maxTXPercentage_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setIsFeeExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setIsTxLimitExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setFeeReceivers(
      _marketingFeeReceiver: string,
      _buybackFeeReceiver: string,
      _liquidityReceiver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getCirculatingSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    getLiquidityBacking(
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    isOverLiquified(
      target: BigNumberish,
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    multiAirdrop(
      addresses: string[],
      tokens: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    manageWhitelist(
      addresses: string[],
      whitelisted: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    enableWhitelistMode(
      enableWhitelist: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    renounceWhitelist(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  _maxTxAmount(overrides?: CallOverrides): Promise<BigNumber>;

  _maxWalletSize(overrides?: CallOverrides): Promise<BigNumber>;

  _rOwned(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  _totalProportion(overrides?: CallOverrides): Promise<BigNumber>;

  claimingFees(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  pair(overrides?: CallOverrides): Promise<string>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  router(overrides?: CallOverrides): Promise<string>;

  swapThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  whitelistEnabled(overrides?: CallOverrides): Promise<boolean>;

  whitelistRenounced(overrides?: CallOverrides): Promise<boolean>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  decimals(overrides?: CallOverrides): Promise<number>;

  name(overrides?: CallOverrides): Promise<string>;

  changeName(
    newName: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  changeSymbol(
    newSymbol: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  symbol(overrides?: CallOverrides): Promise<string>;

  getOwner(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the amount of tokens owned by `account`.
   */
  balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  allowance(
    holder: string,
    spender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  viewFeesBuy(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
  >;

  viewFeesSell(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
  >;

  /**
   * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
   */
  approve(
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  approveMax(
    spender: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
   */
  transfer(
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
   */
  transferFrom(
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  tokensToProportion(
    tokens: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenFromReflection(
    proportion: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTotalFeeBuy(overrides?: CallOverrides): Promise<BigNumber>;

  getTotalFeeSell(overrides?: CallOverrides): Promise<BigNumber>;

  setSwapBackSettings(
    _enabled: boolean,
    _amountS: BigNumberish,
    _amountL: BigNumberish,
    _alternate: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  changeFees(
    _liquidityFeeBuy: BigNumberish,
    _reflectionFeeBuy: BigNumberish,
    _marketingFeeBuy: BigNumberish,
    _buybackFeeBuy: BigNumberish,
    _liquidityFeeSell: BigNumberish,
    _reflectionFeeSell: BigNumberish,
    _marketingFeeSell: BigNumberish,
    _buybackFeeSell: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  SetMaxWalletPercent_base1000(
    maxWallPercent_base1000: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  SetMaxTxPercent_base1000(
    maxTXPercentage_base1000: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setIsFeeExempt(
    holder: string,
    exempt: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setIsTxLimitExempt(
    holder: string,
    exempt: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setFeeReceivers(
    _marketingFeeReceiver: string,
    _buybackFeeReceiver: string,
    _liquidityReceiver: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getCirculatingSupply(overrides?: CallOverrides): Promise<BigNumber>;

  getLiquidityBacking(
    accuracy: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  isOverLiquified(
    target: BigNumberish,
    accuracy: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  multiAirdrop(
    addresses: string[],
    tokens: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  manageWhitelist(
    addresses: string[],
    whitelisted: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  enableWhitelistMode(
    enableWhitelist: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  renounceWhitelist(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    _maxTxAmount(overrides?: CallOverrides): Promise<BigNumber>;

    _maxWalletSize(overrides?: CallOverrides): Promise<BigNumber>;

    _rOwned(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    _totalProportion(overrides?: CallOverrides): Promise<BigNumber>;

    claimingFees(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    pair(overrides?: CallOverrides): Promise<string>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    router(overrides?: CallOverrides): Promise<string>;

    swapThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    whitelistEnabled(overrides?: CallOverrides): Promise<boolean>;

    whitelistRenounced(overrides?: CallOverrides): Promise<boolean>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<number>;

    name(overrides?: CallOverrides): Promise<string>;

    changeName(newName: string, overrides?: CallOverrides): Promise<void>;

    changeSymbol(newSymbol: string, overrides?: CallOverrides): Promise<void>;

    symbol(overrides?: CallOverrides): Promise<string>;

    getOwner(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the amount of tokens owned by `account`.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    allowance(
      holder: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewFeesBuy(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
    >;

    viewFeesSell(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber]
    >;

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    approveMax(spender: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokensToProportion(
      tokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenFromReflection(
      proportion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalFeeBuy(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalFeeSell(overrides?: CallOverrides): Promise<BigNumber>;

    setSwapBackSettings(
      _enabled: boolean,
      _amountS: BigNumberish,
      _amountL: BigNumberish,
      _alternate: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    changeFees(
      _liquidityFeeBuy: BigNumberish,
      _reflectionFeeBuy: BigNumberish,
      _marketingFeeBuy: BigNumberish,
      _buybackFeeBuy: BigNumberish,
      _liquidityFeeSell: BigNumberish,
      _reflectionFeeSell: BigNumberish,
      _marketingFeeSell: BigNumberish,
      _buybackFeeSell: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    SetMaxWalletPercent_base1000(
      maxWallPercent_base1000: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    SetMaxTxPercent_base1000(
      maxTXPercentage_base1000: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsFeeExempt(
      holder: string,
      exempt: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsTxLimitExempt(
      holder: string,
      exempt: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeReceivers(
      _marketingFeeReceiver: string,
      _buybackFeeReceiver: string,
      _liquidityReceiver: string,
      overrides?: CallOverrides
    ): Promise<void>;

    getCirculatingSupply(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityBacking(
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOverLiquified(
      target: BigNumberish,
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    multiAirdrop(
      addresses: string[],
      tokens: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    manageWhitelist(
      addresses: string[],
      whitelisted: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    enableWhitelistMode(
      enableWhitelist: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceWhitelist(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "Approval(address,address,uint256)"(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter;

    "AutoLiquify(uint256,uint256)"(
      amountBNB?: null,
      amountToken?: null
    ): AutoLiquifyEventFilter;
    AutoLiquify(amountBNB?: null, amountToken?: null): AutoLiquifyEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Reflect(uint256,uint256)"(
      amountReflected?: null,
      newTotalProportion?: null
    ): ReflectEventFilter;
    Reflect(
      amountReflected?: null,
      newTotalProportion?: null
    ): ReflectEventFilter;

    "Transfer(address,address,uint256)"(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;
  };

  estimateGas: {
    _maxTxAmount(overrides?: CallOverrides): Promise<BigNumber>;

    _maxWalletSize(overrides?: CallOverrides): Promise<BigNumber>;

    _rOwned(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    _totalProportion(overrides?: CallOverrides): Promise<BigNumber>;

    claimingFees(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pair(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    router(overrides?: CallOverrides): Promise<BigNumber>;

    swapThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    whitelistEnabled(overrides?: CallOverrides): Promise<BigNumber>;

    whitelistRenounced(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    changeName(
      newName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    changeSymbol(
      newSymbol: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    getOwner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the amount of tokens owned by `account`.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    allowance(
      holder: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewFeesBuy(overrides?: CallOverrides): Promise<BigNumber>;

    viewFeesSell(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    approveMax(
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    tokensToProportion(
      tokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenFromReflection(
      proportion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalFeeBuy(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalFeeSell(overrides?: CallOverrides): Promise<BigNumber>;

    setSwapBackSettings(
      _enabled: boolean,
      _amountS: BigNumberish,
      _amountL: BigNumberish,
      _alternate: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    changeFees(
      _liquidityFeeBuy: BigNumberish,
      _reflectionFeeBuy: BigNumberish,
      _marketingFeeBuy: BigNumberish,
      _buybackFeeBuy: BigNumberish,
      _liquidityFeeSell: BigNumberish,
      _reflectionFeeSell: BigNumberish,
      _marketingFeeSell: BigNumberish,
      _buybackFeeSell: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    SetMaxWalletPercent_base1000(
      maxWallPercent_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    SetMaxTxPercent_base1000(
      maxTXPercentage_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setIsFeeExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setIsTxLimitExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setFeeReceivers(
      _marketingFeeReceiver: string,
      _buybackFeeReceiver: string,
      _liquidityReceiver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getCirculatingSupply(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityBacking(
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOverLiquified(
      target: BigNumberish,
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multiAirdrop(
      addresses: string[],
      tokens: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    manageWhitelist(
      addresses: string[],
      whitelisted: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    enableWhitelistMode(
      enableWhitelist: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    renounceWhitelist(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _maxTxAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _maxWalletSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _rOwned(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _totalProportion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimingFees(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pair(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    router(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    swapThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    whitelistEnabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    whitelistRenounced(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    changeName(
      newName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    changeSymbol(
      newSymbol: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the amount of tokens owned by `account`.
     */
    balanceOf(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allowance(
      holder: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewFeesBuy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    viewFeesSell(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    approveMax(
      spender: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    tokensToProportion(
      tokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenFromReflection(
      proportion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalFeeBuy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTotalFeeSell(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setSwapBackSettings(
      _enabled: boolean,
      _amountS: BigNumberish,
      _amountL: BigNumberish,
      _alternate: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    changeFees(
      _liquidityFeeBuy: BigNumberish,
      _reflectionFeeBuy: BigNumberish,
      _marketingFeeBuy: BigNumberish,
      _buybackFeeBuy: BigNumberish,
      _liquidityFeeSell: BigNumberish,
      _reflectionFeeSell: BigNumberish,
      _marketingFeeSell: BigNumberish,
      _buybackFeeSell: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    SetMaxWalletPercent_base1000(
      maxWallPercent_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    SetMaxTxPercent_base1000(
      maxTXPercentage_base1000: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setIsFeeExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setIsTxLimitExempt(
      holder: string,
      exempt: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setFeeReceivers(
      _marketingFeeReceiver: string,
      _buybackFeeReceiver: string,
      _liquidityReceiver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getCirculatingSupply(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLiquidityBacking(
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOverLiquified(
      target: BigNumberish,
      accuracy: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    multiAirdrop(
      addresses: string[],
      tokens: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    manageWhitelist(
      addresses: string[],
      whitelisted: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enableWhitelistMode(
      enableWhitelist: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    renounceWhitelist(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
