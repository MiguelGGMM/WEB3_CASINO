/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface VRFCoordinatorV2InterfaceInterface extends utils.Interface {
  functions: {
    "getRequestConfig()": FunctionFragment;
    "requestRandomWords(bytes32,uint64,uint16,uint32,uint32)": FunctionFragment;
    "createSubscription()": FunctionFragment;
    "getSubscription(uint64)": FunctionFragment;
    "requestSubscriptionOwnerTransfer(uint64,address)": FunctionFragment;
    "acceptSubscriptionOwnerTransfer(uint64)": FunctionFragment;
    "addConsumer(uint64,address)": FunctionFragment;
    "removeConsumer(uint64,address)": FunctionFragment;
    "cancelSubscription(uint64,address)": FunctionFragment;
    "pendingRequestExists(uint64)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getRequestConfig"
      | "requestRandomWords"
      | "createSubscription"
      | "getSubscription"
      | "requestSubscriptionOwnerTransfer"
      | "acceptSubscriptionOwnerTransfer"
      | "addConsumer"
      | "removeConsumer"
      | "cancelSubscription"
      | "pendingRequestExists"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getRequestConfig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "requestRandomWords",
    values: [BytesLike, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createSubscription",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSubscription",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "requestSubscriptionOwnerTransfer",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "acceptSubscriptionOwnerTransfer",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addConsumer",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeConsumer",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelSubscription",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "pendingRequestExists",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "getRequestConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestRandomWords",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createSubscription",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSubscription",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestSubscriptionOwnerTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptSubscriptionOwnerTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addConsumer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeConsumer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelSubscription",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingRequestExists",
    data: BytesLike
  ): Result;

  events: {};
}

export interface VRFCoordinatorV2Interface extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VRFCoordinatorV2InterfaceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Get configuration relevant for making requests
     */
    getRequestConfig(
      overrides?: CallOverrides
    ): Promise<[number, number, string[]]>;

    /**
     * Request a set of random words.
     * @param callbackGasLimit - How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]
     * @param keyHash - Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost.
     * @param minimumRequestConfirmations - How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200].
     * @param numWords - The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle.
     * @param subId - The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash.
     */
    requestRandomWords(
      keyHash: BytesLike,
      subId: BigNumberish,
      minimumRequestConfirmations: BigNumberish,
      callbackGasLimit: BigNumberish,
      numWords: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));
     * Create a VRF subscription.
     */
    createSubscription(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get a VRF subscription.
     * @param subId - ID of the subscription
     */
    getSubscription(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string[]] & {
        balance: BigNumber;
        reqCount: BigNumber;
        owner: string;
        consumers: string[];
      }
    >;

    /**
     * Request subscription owner transfer.
     * @param newOwner - proposed new owner of the subscription
     * @param subId - ID of the subscription
     */
    requestSubscriptionOwnerTransfer(
      subId: BigNumberish,
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * will revert if original owner of subId has not requested that msg.sender become the new owner.
     * Request subscription owner transfer.
     * @param subId - ID of the subscription
     */
    acceptSubscriptionOwnerTransfer(
      subId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Add a consumer to a VRF subscription.
     * @param consumer - New consumer which can use the subscription
     * @param subId - ID of the subscription
     */
    addConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Remove a consumer from a VRF subscription.
     * @param consumer - Consumer to remove from the subscription
     * @param subId - ID of the subscription
     */
    removeConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Cancel a subscription
     * @param subId - ID of the subscription
     * @param to - Where to send the remaining LINK to
     */
    cancelSubscription(
      subId: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    pendingRequestExists(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  /**
   * Get configuration relevant for making requests
   */
  getRequestConfig(
    overrides?: CallOverrides
  ): Promise<[number, number, string[]]>;

  /**
   * Request a set of random words.
   * @param callbackGasLimit - How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]
   * @param keyHash - Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost.
   * @param minimumRequestConfirmations - How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200].
   * @param numWords - The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle.
   * @param subId - The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash.
   */
  requestRandomWords(
    keyHash: BytesLike,
    subId: BigNumberish,
    minimumRequestConfirmations: BigNumberish,
    callbackGasLimit: BigNumberish,
    numWords: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));
   * Create a VRF subscription.
   */
  createSubscription(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get a VRF subscription.
   * @param subId - ID of the subscription
   */
  getSubscription(
    subId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string, string[]] & {
      balance: BigNumber;
      reqCount: BigNumber;
      owner: string;
      consumers: string[];
    }
  >;

  /**
   * Request subscription owner transfer.
   * @param newOwner - proposed new owner of the subscription
   * @param subId - ID of the subscription
   */
  requestSubscriptionOwnerTransfer(
    subId: BigNumberish,
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * will revert if original owner of subId has not requested that msg.sender become the new owner.
   * Request subscription owner transfer.
   * @param subId - ID of the subscription
   */
  acceptSubscriptionOwnerTransfer(
    subId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Add a consumer to a VRF subscription.
   * @param consumer - New consumer which can use the subscription
   * @param subId - ID of the subscription
   */
  addConsumer(
    subId: BigNumberish,
    consumer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Remove a consumer from a VRF subscription.
   * @param consumer - Consumer to remove from the subscription
   * @param subId - ID of the subscription
   */
  removeConsumer(
    subId: BigNumberish,
    consumer: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Cancel a subscription
   * @param subId - ID of the subscription
   * @param to - Where to send the remaining LINK to
   */
  cancelSubscription(
    subId: BigNumberish,
    to: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  pendingRequestExists(
    subId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    /**
     * Get configuration relevant for making requests
     */
    getRequestConfig(
      overrides?: CallOverrides
    ): Promise<[number, number, string[]]>;

    /**
     * Request a set of random words.
     * @param callbackGasLimit - How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]
     * @param keyHash - Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost.
     * @param minimumRequestConfirmations - How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200].
     * @param numWords - The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle.
     * @param subId - The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash.
     */
    requestRandomWords(
      keyHash: BytesLike,
      subId: BigNumberish,
      minimumRequestConfirmations: BigNumberish,
      callbackGasLimit: BigNumberish,
      numWords: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));
     * Create a VRF subscription.
     */
    createSubscription(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get a VRF subscription.
     * @param subId - ID of the subscription
     */
    getSubscription(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string[]] & {
        balance: BigNumber;
        reqCount: BigNumber;
        owner: string;
        consumers: string[];
      }
    >;

    /**
     * Request subscription owner transfer.
     * @param newOwner - proposed new owner of the subscription
     * @param subId - ID of the subscription
     */
    requestSubscriptionOwnerTransfer(
      subId: BigNumberish,
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * will revert if original owner of subId has not requested that msg.sender become the new owner.
     * Request subscription owner transfer.
     * @param subId - ID of the subscription
     */
    acceptSubscriptionOwnerTransfer(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Add a consumer to a VRF subscription.
     * @param consumer - New consumer which can use the subscription
     * @param subId - ID of the subscription
     */
    addConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove a consumer from a VRF subscription.
     * @param consumer - Consumer to remove from the subscription
     * @param subId - ID of the subscription
     */
    removeConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel a subscription
     * @param subId - ID of the subscription
     * @param to - Where to send the remaining LINK to
     */
    cancelSubscription(
      subId: BigNumberish,
      to: string,
      overrides?: CallOverrides
    ): Promise<void>;

    pendingRequestExists(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {};

  estimateGas: {
    /**
     * Get configuration relevant for making requests
     */
    getRequestConfig(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Request a set of random words.
     * @param callbackGasLimit - How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]
     * @param keyHash - Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost.
     * @param minimumRequestConfirmations - How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200].
     * @param numWords - The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle.
     * @param subId - The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash.
     */
    requestRandomWords(
      keyHash: BytesLike,
      subId: BigNumberish,
      minimumRequestConfirmations: BigNumberish,
      callbackGasLimit: BigNumberish,
      numWords: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));
     * Create a VRF subscription.
     */
    createSubscription(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get a VRF subscription.
     * @param subId - ID of the subscription
     */
    getSubscription(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Request subscription owner transfer.
     * @param newOwner - proposed new owner of the subscription
     * @param subId - ID of the subscription
     */
    requestSubscriptionOwnerTransfer(
      subId: BigNumberish,
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * will revert if original owner of subId has not requested that msg.sender become the new owner.
     * Request subscription owner transfer.
     * @param subId - ID of the subscription
     */
    acceptSubscriptionOwnerTransfer(
      subId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Add a consumer to a VRF subscription.
     * @param consumer - New consumer which can use the subscription
     * @param subId - ID of the subscription
     */
    addConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Remove a consumer from a VRF subscription.
     * @param consumer - Consumer to remove from the subscription
     * @param subId - ID of the subscription
     */
    removeConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Cancel a subscription
     * @param subId - ID of the subscription
     * @param to - Where to send the remaining LINK to
     */
    cancelSubscription(
      subId: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    pendingRequestExists(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Get configuration relevant for making requests
     */
    getRequestConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Request a set of random words.
     * @param callbackGasLimit - How much gas you'd like to receive in your fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords may be slightly less than this amount because of gas used calling the function (argument decoding etc.), so you may need to request slightly more than you expect to have inside fulfillRandomWords. The acceptable range is [0, maxGasLimit]
     * @param keyHash - Corresponds to a particular oracle job which uses that key for generating the VRF proof. Different keyHash's have different gas price ceilings, so you can select a specific one to bound your maximum per request cost.
     * @param minimumRequestConfirmations - How many blocks you'd like the oracle to wait before responding to the request. See SECURITY CONSIDERATIONS for why you may want to request more. The acceptable range is [minimumRequestBlockConfirmations, 200].
     * @param numWords - The number of uint256 random values you'd like to receive in your fulfillRandomWords callback. Note these numbers are expanded in a secure way by the VRFCoordinator from a single random value supplied by the oracle.
     * @param subId - The ID of the VRF subscription. Must be funded with the minimum subscription balance required for the selected keyHash.
     */
    requestRandomWords(
      keyHash: BytesLike,
      subId: BigNumberish,
      minimumRequestConfirmations: BigNumberish,
      callbackGasLimit: BigNumberish,
      numWords: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * You can manage the consumer set dynamically with addConsumer/removeConsumer.Note to fund the subscription, use transferAndCall. For exampleLINKTOKEN.transferAndCall(address(COORDINATOR),amount,abi.encode(subId));
     * Create a VRF subscription.
     */
    createSubscription(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a VRF subscription.
     * @param subId - ID of the subscription
     */
    getSubscription(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Request subscription owner transfer.
     * @param newOwner - proposed new owner of the subscription
     * @param subId - ID of the subscription
     */
    requestSubscriptionOwnerTransfer(
      subId: BigNumberish,
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * will revert if original owner of subId has not requested that msg.sender become the new owner.
     * Request subscription owner transfer.
     * @param subId - ID of the subscription
     */
    acceptSubscriptionOwnerTransfer(
      subId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Add a consumer to a VRF subscription.
     * @param consumer - New consumer which can use the subscription
     * @param subId - ID of the subscription
     */
    addConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove a consumer from a VRF subscription.
     * @param consumer - Consumer to remove from the subscription
     * @param subId - ID of the subscription
     */
    removeConsumer(
      subId: BigNumberish,
      consumer: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel a subscription
     * @param subId - ID of the subscription
     * @param to - Where to send the remaining LINK to
     */
    cancelSubscription(
      subId: BigNumberish,
      to: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    pendingRequestExists(
      subId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
